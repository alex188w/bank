# Микросервисное приложение «Банк» — это приложение с веб-интерфейсом, которое позволяет пользователю (клиенту банка):

    регистрироваться и авторизовываться в приложении по логину и паролю (при регистрации в приложении автоматически создается пользователь с логином и паролем на сервере авторизации KeyKloak, авторизация происходит с перенаправлением на сервер авторизации KeyKloak);

    класть виртуальные деньги на счёт своего аккаунта и снимать их;

    переводить виртуальные деньги на счёт другого аккаунта.

    
## Приложение состоит из следующих микросервисов:
    фронт (gateway-service);
    сервиса аккаунтов (accounts-service);
    сервиса обналичивания денег (cash-service);
    сервиса перевода денег на счёт другого аккаунта (transfer-service);
    cервиса конвертации валют (exchange-service);
    сервиса генерации курсов валют (exchange-generator);
    сервиса уведомлений (notifications-service).


## Функциональность

* Микросервисы приложения написаны на Spring Boot и собираются с помощью Maven.

* Код приложения хранится в Git-репозитории (Github) по адресу: https://github.com/alex188w/bank.

* Есть возможность собирать сразу все микросервисы одной командой с помощью parent POM и использования мультимодульных проектов.

* Код приложения написан на Java 21.

* Web UI приложения использует Spring WebFlux.

* Приложение используеть Spring Data R2DBC для доступа к данным в базе данных.

* База данных для микросервисов приложения - персистентная (PostgreSQL). БД - одна, но разграничивает микросервисы на уровне схем, чтобы реализовать паттерн Database per Service.

* В качестве Service Discovery и Gateway API применен Consul, реализующий паттерны Service Discovery и Gateway API, с использованием проекта Spring Cloud Gateway.

* Микросервисы выполняют запросы в другие микросервисы через Gateway API и регистрируются в Service Discovery.

* В качестве Externalized/Distributed Config применен Consul, реализующий паттерн Externalized/Distributed Config, с использованием проекта Spring Cloud Config.

* Микросервисы получают общие настройки из Externalized/Distributed Config.

* В качестве сервера авторизации OAuth 2.0 используется сервер авторизации OAuth 2.0 Keycloak, с использованием проекта Spring Security OAuth.

* Микросервисы авторизуются на сервере OAuth 2.0 Keycloak, получают Access Token (JWT) по client credentials для выполнения запросов в другие микросервисы.

* Микросервисы приложения можно собрать из исходников и запустить локально.
Микросервисы приложения могут быть упакованы в Executable JAR и запускаться в Netty.

* Приложение покрыто тестами (юнит, интеграционными, контрактными) с использованием JUnit 5, TestContext Framework, Spring Boot Test, кеширования контекстов и Spring Cloud Contract.

* Микросервисы написаны и протестированы с использованием паттернов микросервисной архитектуры приложения.

* Executable JAR микросервисов могут быть упакованы в Docker-контейнеры с открытым веб-портом для доступа из браузера и межсервисного взаимодействия, чтобы реализовать паттерн Single Service per Host.

* Запускать микросервисы можно все вместе с помощью Docker Compose или по одному вручную с помощью команд Docker.

## Краткое описание работы приложения

1. Фронт (gateway-service)
Фронт — это веб-приложение с клиентским HTML-интерфейсом. Предоставляет следующие HTML-страницы:

    1.1. Cтраницу регистрации, если пользватель зарегистрирован, предусмотрена кнопка "Войти", после нажатия на которую пользователь перенаправляется на сервер авторизации OAuth 2.0 Keycloak. При регистрации данные пользователя сохраняются в БД приложеня и автоматически создается пользователь в KeyKloak с возможностью полноценной работы в приложении. После регистрации пользователь автоматически перенапрвляется на страницу авторизации KeyKloak, после авторизации - на главную страницу приложения - http://localhost:8080/bank. Здесь же есть ссылка, при нажатии на которую, пользователь разлогинивается.

    1.2. Главная страница приложения - доступна только после успешной аутентификации/авторизации пользователя. 

    Страница содержит:

    блок внесения и снятия виртуальных денег;

    блок перевода денег на счёт другого аккаунта;

    блок конвертации валют.

2. Сервис аккаунтов (accounts-service)

Сервис аккаунтов хранит информацию о зарегистрированных аккаунтах и их счетах (именно в нём хранятся логин, счета пользователя и и наличие на них денег, которые становятся достцпными после аутентификации пользователя на сервере авторизации OAuth 2.0 Keycloak).

Фронт выполняет REST-запросы (в формате JSON) из блока внесения и снятия виртуальных денег и блока перевода денег на счёт другого аккаунта в accounts-service.

В свою очередь, accounts-service выполняет REST-запросы (в формате JSON) в Notifications.
                        
Также в accounts-service приходят запросы при регистрации нового аккаунта (из формы регистрации).

3. Сервис обналичивания денег (cash-service)

Сервис обналичивания денег осуществляет пополнение счёта или снятие денег со счёта.

Фронт выполняет REST-запросы (в формате JSON) из блока внесения и снятия виртуальных денег в сервис Cash.

В свою очередь, Cash выполняет REST-запросы (в формате JSON) в accounts-service и Notifications.

4. Сервис перевода денег между счетами (transfer-service)

Сервис перевода денег между счетами осуществляет перевод денег между счетами разных пользователей.

Фронт выполняет REST-запросы (в формате JSON) из блока перевода денег на счёт другого аккаунта в сервис transfer-service. 

В свою очередь, transfer-service выполняет REST-запросы (в формате JSON) в accounts-service и Notifications.

5. Сервиса генерации курсов валют (exchange-generator)

Сервиса генерации курсов валют делает GET-запрос к внешнему открытому для всех API https://open.er-api.com/v6/latest/RUB c периодичностью один раз в минуту. Ввиду открытости сервиса не защищен SpringSequrity. Выполняет REST-запросы (в формате JSON) в сервис exchange-service.

6. Сервиса конвертации валют (exchange-service);

Сервиса конвертации валют - получает текущие курсы валют от exchange-generator иконвертирует их (конвртация не используется фронтом - только вывод текущего курса). Фронт выполняет REST-запросы (в формате JSON) из блока курсов валют в сервис exchange-service для получения информации о курсах валют.

7. Сервис уведомлений (notifications-service)

Сервис уведомлений отправляет уведомления - Alert пользователю о выполненном действии: переводе денег, пополнении счёта, снятии денег со счёта и т. д.

Микросервисы аутентифицируются/авторизуются на сервере авторизации OAuth 2.0 Keycloak по client credentials, чтобы выполнять запросы в другие микросервисы. 

Аутентификация/авторизация пользователей - по логину/паролю. У пользователя есть доступ к информации только о своём аккаунте и счёте.


## Запуск приложения в работу

Для корректной работы приложения необходимо:

- Запустить контейнер consul в Докере на порту 8500 командой: docker run -d --name=consul -p 8500:8500 consul:1.14 (при работе на Виндовс Докер Десктоп должен быть запущен)

- Запустить локально на Виндовс: сервер авторизации OAuth 2.0 Keycloak.

- В Keycloak должен быть создан Realm - bank и созданы клиенты: account-service, gateway-service, cash-service, exchange-service, transfer-service, notifications-service, присвоены роли: openid, profile, email и получены client-secret, котрые нужно будет прописать в application.yml каждого сервиса.

- Запустить локально на Виндовс PostgreSQL и создать БД bank c двумя схемамми:

1. account - таблица account с соответствующими модели полями;

2. 


- Для сборки и запуска приложения из исходников локально на хостовой машине ОС Виндовс нужно последовательно запустить в работу каждый микросервис командами:

mvn -pl account-service spring-boot:run

mvn -pl gateway-service spring-boot:run

mvn -pl cash-service spring-boot:run

mvn -pl exchange-service spring-boot:run

mvn -pl exchange-generator spring-boot:run 

mvn -pl transfer-service spring-boot:run

mvn -pl notifications-service spring-boot:run 

- Для удобства запуска всех сервисов создан скрипт run-all.sh. При его запуске - стартуют все микросервисы и записывается pid каждого, для возможности их остановки с помощью скрипта stop-all.sh.

    
Для корректной работы приложения в корне проекта нужно создать файлы:

1. для работы в локальной среде: 
storefront\src\main\resources\application-local.yml

    spring:
    r2dbc:
        url: r2dbc:postgresql://localhost:5432/toyshop
        username: your_userName
        password: your_userPassword
    data:
        redis:
        host: localhost
        port: 6379

    payment:
    service:
        url: http://localhost:8081


2. для работы в контейнере: 

storefront\src\main\resources\application-docker.yml

    spring:
        r2dbc:
            url: r2dbc:postgresql://host.docker.internal:5432/toyshop
            username: your_userName
            password: your_userPassword
        data:
            redis:
            host: redis
            port: 6379

        payment:
        service:
            url: http://payment-service:8081


Название БД прописано в строке (изменить при необходимости):

    url: r2dbc:postgresql://host.docker.internal:5432/db_name

## Сервис платежей представляет собой RESTful-приложение с двумя реактивными HTTP-эндпоинтами:

* получением баланса на счёте (на ваш выбор логика получения баланса: случайный баланс, загрузка из БД, фиксированный баланс, загрузка из конфига) — если баланс меньше суммы цены товаров в корзине, то кнопка оформления заказа основного приложения недоступна;

* осуществлением платежа (при нажатии на кнопку оформления заказа происходит запрос на вычитание суммы заказа из баланса) — если оно даёт отрицательный результат, то считается, что оплата заказа не прошла и он не оформляется, и выдаётся соответствующая ошибка.

Образ контейнера доступен по адресу: https://hub.docker.com/repository/docker/alex188w/payment-service


Сервер Redis использeтся в качестве кеша товаров, может быть установлен как локально (при разработке в локальной среде), так и в Docker-контейнере (при запуске приложения в контейнере)

## Запуск приложения в работу

1. Сборка и запуск приложения из исходников локально на хостовой машине ОС Виндовс (БД должна быть запущена на хостовой машине) возможно командми:

 **mvn spring-boot:run -pl paymentService** - запуск сервиса платежей

 **mvn spring-boot:run -pl storefront "-Dspring-boot.run.profiles=local"** - запуск основного приложения

 Сервис Redis должен быть обязательно запущен на хостовой машине!

При этом: 

    Собирается приложения (компилирует Java-код, копирует ресурсы, прогоняет аннотации).

    Поднимается приложение прямо из исходников — без явного создания JAR.

    Подтягиваются зависимости на лету из локального Maven-репозитория (~/.m2/repository).

    Передаются в приложение все свойства (из application.yml).

    Проект остается в «живом» состоянии — пока не остановим процесс (Ctrl+C).

Приложение открывается по адресу: http://localhost:8085/products


2. Запуск Executable JAR в Docker-контейнер с открытым веб-портом для доступа из браузера (8085) с использованием Docker Compose.

В корне проектов должны быть созданы файлы - Dockerfile, в котором описываются инструкции для сборки образа Docker — шаги, которые скажут Docker, как подготовить среду для приложения.

Также в корне проекта должен быть создан файл docker-compose.yml (доступен в репозитории), в котором описывается, как запускать контейнер — с его настройками, сетями, томами и переменными окружения. 
  
DockerCompose должны быть установлены и запущены на компьютере. Проверить можно командой:

    •	Версия Docker: docker --version
    •	Версия Docker Compose: docker compose version


Запуск приложения возможен одним из следующих вариантов:

    2.1. Скачать приложения из репозитория ДокерХаб.

    Запустить приложение командой: docker-compose up --build.


    2.2. Чистим и собираем fat JAR - ы из исходников командой: mvn clean package -DskipTests

    После этого в папках target/ появится файлы

    Затем нужно запустить через Docker Compose командой:	docker compose up --build.

    После этого приложение будет доступно в браузере по адресу: http://localhost:8085/products


## Тестирование

Приложение покрыто модульными и интеграционными тестами с использованием Spring Boot Test, Spring WebFlux и Spring Data R2DBC и кеширования контекстов.

Интеграционное тестирвание выполняется в условиях, максимально приближенных к реальной среде выполнения приложения с использованием Testcontainers с PostgreSQL для Spring Boot.

Этот метод имеет следующие преимущества:

    Изоляция: тесты не зависят от локальной базы данных или внешних сервисов.

    Воспроизводимость: одна и та же конфигурация базы для всех тестов и разработчиков.

    Чистая база: можно легко сбрасывать состояние между тестами или перед каждым запуском.

    Быстрый старт/стоп: контейнер запускается и останавливается быстро.

    Контроллеры и сервисы подключаются к реальному слою данных через полноценный Spring-контекст.

Всего для покрытия Приложения тестами (юнит-, интеграционными) создано 48 тест.в (37 - тестироание основного приложени и 11 сервиса платежей)

Запуск всех тестов выполняется командой: mvn test

Запуск отдельно класса с тестами командой: mvn test -Dtest=TestClassName

Результаты тестирования:

Основное приложение:


![Результаты тестирования](img/paymentServiceTest.jpg)


Сервис платежей:


![Результаты тестирования](img/storefrontTest.jpg)




## Скрины основных страниц приложения:

Главная страница прилоржения:

![Главная страница](img/products.jpg)

Страница товара:

![Страница товара](img/product.jpg)

Страница корзины:

![Страница корзины](img/cart.jpg)

Страница заказа:

![Страница заказа](img/order.jpg)

Страница заказов:

![Страница заказов](img/orders.jpg)

Страница добавления товара:

![Страница добавления](img/product-add.jpg)