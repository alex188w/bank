input {
  kafka {
    bootstrap_servers => "${KAFKA_BOOTSTRAP_SERVERS}"
    topics => ["${KAFKA_TOPIC}"]
    group_id => "${KAFKA_GROUP_ID}"
    auto_offset_reset => "latest"
    consumer_threads => 1
    codec => json
  }
}

filter {
  # Если вдруг лог прилетел не JSON, можно fallback:
  if ![ts] and [message] {
    mutate { add_tag => ["unparsed"] }
  }

  # Нормализуем timestamp
  if [ts] {
    date {
      match => ["ts", "ISO8601"]
      target => "@timestamp"
    }
  }

  # ----- ФИЛЬТРАЦИЯ ПО СРЕДЕ (single-ELK) -----
  # Пропускать всё, что не соответствует envValue
  if "${ENV_FILTER_ENABLED}" == "true" {
    if ![env] or [env] != "${ENV_VALUE}" {
      drop { }
    }
  }

  # ----- МАСКИРОВАНИЕ / ХЕШИРОВАНИЕ -----
  # 1) Пароли — вообще выкинуть (лучше не логировать, но на всякий)
  # if [password] { mutate { remove_field => ["password"] } }
  # if [newPassword] { mutate { remove_field => ["newPassword"] } }

  # 2) Пример: accountNumber / cardNumber маскируем
  if [accountNumber] {
    mutate {
      gsub => [
        "accountNumber", "(?<=\\d{2})\\d(?=\\d{2})", "*"
      ]
    }
  }

  # 3) Хешируем accountId / login если хочешь совсем убрать идентификаторы
  # fingerprint даст детерминированный хеш (удобно для агрегаций)
  if [accountId] {
    fingerprint {
      source => "accountId"
      target => "accountIdHash"
      method => "SHA256"
      key => "${FINGERPRINT_KEY}"
    }
    mutate { remove_field => ["accountId"] }
  }

  if [login] {
    fingerprint {
      source => "login"
      target => "loginHash"
      method => "SHA256"
      key => "${FINGERPRINT_KEY}"
    }
    mutate { remove_field => ["login"] }
  }

  # Удобные поля для Kibana
  mutate {
    rename => { "service" => "service.name" }
    add_field => { "event.dataset" => "bank-platform" }
  }
}

output {
  elasticsearch {
    hosts => ["${ES_HOSTS}"]
    index => "bank-logs-%{[env]}-%{+YYYY.MM.dd}"
  }

  # Для дебага можно включать stdout в dev:
  if "${DEBUG_STDOUT}" == "true" {
    stdout { codec => rubydebug }
  }
}